# Sigil IPFS Storage System

A comprehensive, privacy-preserving storage system for the Sigil Web3 developer credentials platform. This system uses IPFS (via Helia) to store ZK proofs, verifiable credentials, and aggregated developer data while maintaining strong privacy guarantees and seamless integration with smart contracts and ZK circuits.

## Overview

The Sigil storage system is designed to handle the unique requirements of a privacy-preserving developer credentials platform:

- **ZK Proof Storage**: Efficiently store and retrieve zero-knowledge proofs generated by circuits
- **Credential Management**: Handle verifiable credentials with proper validation and expiration
- **Privacy-First**: Client-side encryption and differential privacy for sensitive data
- **High Availability**: Multi-provider pinning and redundancy for critical content
- **Smart Contract Integration**: Seamless coordination with on-chain verification contracts
- **Performance Optimization**: Advanced caching and retrieval optimization

## Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                    Sigil Storage Manager                    │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │    IPFS     │  │ Encryption  │  │   Pinning   │         │
│  │   Client    │  │   Service   │  │   Service   │         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │    Cache    │  │  Retrieval  │  │  Garbage    │         │
│  │   Service   │  │   Service   │  │ Collection  │         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
└─────────────────────────────────────────────────────────────┘
```

## Key Components

### 1. **IPFS Client** (`/ipfs/client.ts`)
- Modern Helia-based IPFS implementation
- Optimized for ZK proof and credential storage
- Automatic retry and fallback mechanisms
- Circuit-specific storage optimization

### 2. **Encryption Service** (`/encryption.ts`)
- Client-side encryption using AES-256-GCM
- Wallet-derived keys for user-specific encryption
- Deterministic encryption for ZK proofs
- Support for multiple key derivation methods

### 3. **Pinning Service** (`/pinning.ts`)
- Multi-provider pinning for redundancy
- Automatic failover and repair
- Health monitoring and alerting
- Cost optimization across providers

### 4. **Cache Service** (`/cache/`)
- LRU/LFU/FIFO caching strategies
- Content-aware caching with tags
- Automatic cleanup and expiration
- Circuit and credential-specific optimization

### 5. **Retrieval Service** (`/retrieval.ts`)
- Multi-source retrieval with fallbacks
- Content validation and integrity checking
- Performance optimization and preloading
- Gateway fallback for high availability

### 6. **Garbage Collection** (`/garbage_collection.ts`)
- Automated storage cleanup
- Retention policies for different content types
- Emergency cleanup for storage pressure
- Privacy-aware data archival

## Content Types

### ZK Proof Content
```typescript
interface ZKProofContent {
  contentType: 'zk-proof'
  circuit: {
    type: 'repository' | 'language' | 'collaboration' | 'aggregate'
    name: string
    version: string
    wasmCID: CID
    zkeyHash: string
  }
  proof: {
    pi_a: [string, string]
    pi_b: [[string, string], [string, string]]
    pi_c: [string, string]
    protocol: string
    curve: string
  }
  publicSignals: string[]
  verificationKey: any
  metadata: ProofMetadata
}
```

### Verifiable Credential Content
```typescript
interface VerifiableCredentialContent {
  contentType: 'verifiable-credential'
  '@context': string[]
  type: string[]
  issuer: string | IssuerObject
  issuanceDate: string
  expirationDate?: string
  credentialSubject: {
    id: string
    type: string
    claims: CredentialClaims
  }
  proof: CredentialProof
}
```

### Aggregated Data Content
```typescript
interface AggregatedDataContent {
  type: 'aggregated-data'
  repositories: RepositoryData[]
  languages: LanguageData[]
  collaboration: CollaborationData
  temporal: TemporalData
  metadata: AggregationMetadata
}
```

## Integration with Contracts

The storage system seamlessly integrates with Sigil's smart contracts:

### Contract References
```typescript
interface ContractReference {
  address: string
  network: string
  verifierType: string
  deploymentBlock: number
  abi: any[]
}
```

### On-Chain References
```typescript
interface OnChainReference {
  transactionHash: string
  blockNumber: number
  contractAddress: string
  eventLogs: any[]
  gasUsed: number
}
```

## Integration with Circuits

### Circuit Proof Storage
```typescript
interface CircuitProofStorage {
  proofData: Uint8Array
  publicInputs: string[]
  circuitWasm: CID
  circuitZkey: CID
  verificationKey: any
  circuitMetadata: {
    name: string
    version: string
    constraints: number
    variables: number
  }
}
```

## Usage Examples

### Basic Setup

```typescript
import { createSigilStorage } from '@sigil/storage'

const config = {
  ipfs: {
    nodes: [{ url: 'http://localhost:5001', timeout: 30000 }],
    pinningServices: [
      {
        name: 'pinata',
        endpoint: 'https://api.pinata.cloud/psa',
        accessToken: 'your-token',
        priority: 1,
        enabled: true
      }
    ],
    gateway: {
      publicGateways: ['https://ipfs.io', 'https://cloudflare-ipfs.com'],
      timeout: 10000,
      fallbackEnabled: true
    }
  },
  encryption: {
    algorithm: 'AES-256-GCM',
    keyDerivation: 'PBKDF2',
    saltLength: 32,
    iterations: 100000
  },
  cache: {
    maxSize: 100 * 1024 * 1024, // 100MB
    ttl: 3600000, // 1 hour
    cleanupInterval: 300000, // 5 minutes
    strategy: 'LRU'
  }
}

const storage = await createSigilStorage(config)
```

### Storing ZK Proofs

```typescript
const proofContent = {
  type: 'zk-proof',
  circuitType: 'repository',
  proof: proofData,
  publicSignals: ['signal1', 'signal2'],
  metadata: {
    version: '1.0.0',
    timestamp: Date.now(),
    expiresAt: Date.now() + 86400000,
    circuitHash: 'hash...',
    verifierContract: '0x...',
    userAddress: '0x...',
    credentialType: 'repository'
  }
}

const result = await storage.storeProof(proofContent, {
  encrypt: true,
  pin: true,
  redundancy: 2
})

console.log(`Proof stored: ${result.cid}`)
```

### Storing Verifiable Credentials

```typescript
const credentialContent = {
  type: 'credential',
  format: 'w3c',
  credential: {
    // W3C Verifiable Credential structure
  },
  proof: proofContent,
  metadata: {
    issuer: 'did:sigil:issuer',
    subject: 'did:sigil:user',
    issuedAt: Date.now(),
    expiresAt: Date.now() + 31536000000, // 1 year
    credentialSchema: 'SigilDeveloperCredential',
    tags: ['developer', 'repository', 'verified']
  }
}

const result = await storage.storeCredential(credentialContent, {
  encrypt: true,
  pin: true
})

console.log(`Credential stored: ${result.cid}`)
```

### Retrieving Content

```typescript
// Retrieve with automatic decryption and validation
const proof = await storage.retrieveProof(cid, {
  verifyIntegrity: true,
  decryptionKey: 'user-key'
})

const credential = await storage.retrieveCredential(cid, {
  verifyIntegrity: true
})

// Batch retrieval
const cids = ['QmHash1...', 'QmHash2...', 'QmHash3...']
const contents = await storage.batchRetrieve(cids)
```

### Wallet-Based Encryption

```typescript
// Encrypt data with wallet signature
const encrypted = await storage.encryptWithWallet(
  'sensitive data',
  '0x1234...', // wallet address
  'signature...' // wallet signature
)

// Decrypt with same wallet
const decrypted = await storage.decryptWithWallet(
  encrypted,
  '0x1234...',
  'signature...'
)
```

## Privacy Features

### Differential Privacy
```typescript
const aggregatedData = {
  type: 'aggregated-data',
  // ... data
  metadata: {
    privacyLevel: 'differential-private',
    noiseParameters: {
      epsilon: 0.1,
      delta: 1e-5
    }
  }
}
```

### K-Anonymity
```typescript
const anonymizedData = {
  // ... data
  metadata: {
    privacyLevel: 'k-anonymous',
    k: 5 // Minimum group size
  }
}
```

## Configuration

### Storage Configuration
```typescript
interface StorageConfig {
  ipfs: IPFSConfig
  encryption: EncryptionConfig
  cache: CacheConfig
  redundancy: RedundancyConfig
}
```

### Garbage Collection Configuration
```typescript
interface GCConfig {
  maxStorageSize: number
  maxAge: number
  retentionPolicies: RetentionPolicy[]
  scheduledCleanup: boolean
  cleanupInterval: number
}
```

## Monitoring and Metrics

```typescript
const metrics = await storage.getMetrics()
console.log({
  totalStoredBytes: metrics.totalStoredBytes,
  totalContentItems: metrics.totalContentItems,
  cacheHitRate: metrics.cacheHitRate,
  redundancyHealth: metrics.redundancyHealth,
  costMetrics: metrics.costMetrics
})
```

## Error Handling

```typescript
import { StorageError, StorageErrorCode } from '@sigil/storage'

try {
  await storage.storeProof(proofContent)
} catch (error) {
  if (error instanceof StorageError) {
    switch (error.code) {
      case StorageErrorCode.CONNECTION_FAILED:
        // Handle connection issues
        break
      case StorageErrorCode.ENCRYPTION_FAILED:
        // Handle encryption issues
        break
      case StorageErrorCode.INSUFFICIENT_REDUNDANCY:
        // Handle redundancy issues
        break
    }
  }
}
```

## Performance Optimization

### Caching Strategies
- **LRU**: Least Recently Used (default for general content)
- **LFU**: Least Frequently Used (for frequently accessed proofs)
- **FIFO**: First In, First Out (for temporary content)

### Preloading
```typescript
// Preload frequently accessed content
await storage.getServices().retrieval.preload([
  'QmProof1...',
  'QmCredential1...',
  'QmProfile1...'
])
```

### Batch Operations
```typescript
// Batch store for efficiency
const results = await storage.batchStore([
  { content: proof1, options: { encrypt: true } },
  { content: credential1, options: { pin: true } },
  { content: aggregatedData1, options: { redundancy: 3 } }
])
```

## Security Considerations

1. **Client-Side Encryption**: All sensitive data is encrypted before storage
2. **Key Management**: Wallet-derived keys ensure user control
3. **Content Validation**: Automatic integrity checking and validation
4. **Access Control**: Tag-based access control and user isolation
5. **Privacy Preservation**: Differential privacy and k-anonymity support

## Circuit Integration Best Practices

1. **Deterministic Encryption**: Use circuit hash for proof encryption
2. **Metadata Consistency**: Ensure circuit metadata matches stored proofs
3. **Version Management**: Track circuit versions with stored proofs
4. **Verification Key Storage**: Store verification keys with circuit metadata

## Contract Integration Best Practices

1. **Event Logging**: Store contract references with credentials
2. **Gas Optimization**: Batch operations to reduce gas costs
3. **Upgrade Safety**: Handle contract upgrades gracefully
4. **Cross-Chain Support**: Support multiple networks and contracts

## Development

### Running Tests
```bash
npm test
```

### Building
```bash
npm run build
```

### Linting
```bash
npm run lint
```

## Contributing

See the main Sigil contributing guidelines for development setup and contribution process.

## License

This project is licensed under the MIT License - see the LICENSE file for details. 